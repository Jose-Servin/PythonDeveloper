# Next Level Python Course

Resources:

* [Link to course](https://academy.arjancodes.com/next-level-python)
* [Source Code](../Projects/NextLevelPython/)

## Static Typing

In static typing, variables are explicitly declared with their data types at compile time, and the type checking is performed at compile time.
Once a variable is declared with a specific data type, it cannot hold values of any other type. This restriction helps catch type-related errors early in the development process.
Examples of statically typed languages include Java, C, C++, and Swift.

## Dynamic Typing

In dynamic typing, variables are not bound to a specific data type at compile time. Instead, the type of a variable is determined at runtime based on the value assigned to it.
Type checking is typically performed at runtime, as opposed to compile time. This means that type errors might only be discovered while the program is running.
Dynamic typing provides more flexibility as variables can hold values of any type and can change their type during runtime.
Examples of dynamically typed languages include Python, JavaScript, and Ruby.

## Duck Typing In Python

In Python, instead of checking if an object belongs to a specific class or type, you check if it supports certain methods or behaviors. If an object implements the necessary methods or attributes, it can be used in a particular context, regardless of its actual type or class.

In `../Projects/NextLevelPython/duck_typing.py` we see the `len()` function expects an Object of type `Sized` which means this Object needs to have a `__len__()` dunder method.

[In other words](https://www.pythonmorsels.com/making-the-len-function-work-on-your-python-objects/):

```text
Python's built-in len function calls the __len__ method (pronounced "dunder len") on the object you give it.

So if that object has a __len__ method, it has a length.
```

## Type Hint/Annotation

It's easy to add type hints in Python, we simply use the `:` and declare what type our variable is/what variables it's made of.

```python
my_str: str = "Hello World"
my_list: list[int] = [34, 54, 65, 78]
my_dict: dict[str, int] = {"one": 123, "two": 456, "three": 789}
```

For instances where we provide the "wrong" type hint, we won't see an error because python does not execute type hints. We must remember that type hints are for the Developer to debug and understand variable requirements.

We can use `strict` type checking mode in VSCode by adding the following setting in our workspace.json file. See [VSCode Docs](https://code.visualstudio.com/docs/python/settings-reference#_python-language-server-settings)

```json
"settings":
    {
        "python.analysis.typeCheckingMode": "strict"
    }
```

We can also leverage the union type syntax which allows us to declare "or" statements when specifying type hints. We can see this in the `protocol_before.py` `EmailClient` class initializer.

```python
class EmailClient:
    def __init__(
        self,
        login: str | None = None,
        password: str | None = None,
        name: str | None = None,
        to_address: str = DEFAULT_EMAIL,
    ):
```

### Protocol Class

"A protocol is a set of methods or attributes that an object must have in order to be considered compatible with that protocol. Protocols enable you to define interfaces without explicitly creating a class or inheriting from a specific base class."

[Reference Link](https://dev.to/shameerchagani/what-is-a-protocol-in-python-3fl1)

To understand this, we will look at `../Projects/NextLevelPython/protocol_before.py`. This file contains an `EmailClient` class which represents the scaffold for a basic email sending system. The breakdown is very simple:

1. Initializer captures user information.
2. Create `SMTP` server and log in using user provided credentials.
3. Build Connect and Quit server connections methods.
4. Build a Send Email method that calls the `SMTP` methods defined previously.

Now, the way we've developed this `EmailClient` functionality has created a dependency between our custom `EmailClient` class and the library which provides the `SMTP`.

To remove this dependency and improve our `EmailClient` implementation we use a `Protocol` class. Here, we will specify the structure of the object we should expect, i.e the structure our `self._server` should have and not worry about specifics.

The file, `../Projects/NextLevelPython/protocol_after.py` contains the `Protocol` implementation.

We first start by defining the "Protocol" an `EmailServer` should follow.

```python
from typing import Protocol

DEFAULT_EMAIL = "support@arjancodes.com"
LOGIN = "admin"
PASSWORD = "admin"


class EmailServer(Protocol):
    @property
    def _host(self) -> str: ...

    def connect(self, host: str, port: int) -> None: ...

    def starttls(self) -> None: ...

    def login(self, login: str, password: str) -> None: ...

    def quit(self) -> None: ...

    def sendmail(self, from_address: str, to_address: str,
                 message: str) -> None: ...

```

And now, we pass this `EmailServer` protocol as the instance type of the `smtp_server` used in our `EmailClient`.

```python
class EmailClient:
    def __init__(
        self,
        smtp_server: EmailServer,
        login: str | None = None,
        password: str | None = None,
        name: str | None = None,
        to_address: str = DEFAULT_EMAIL,
    ):
```

So now, when we initialize our `EmailClient` we pass whatever `SMTP` server instance we want to use - as long as that instance contains the methods in our `EmailServer` protocol. This works because we've provided the Protocol as the type for this `smtp_server` which is provided to our `EmailClient` in the initializer. This is called Dependency Injection; [learn more about this](https://www.youtube.com/watch?v=fhwhQjY2GCY&ab_channel=ArjanCodes)
