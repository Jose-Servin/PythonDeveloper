# Next Level Python Course

Resources:

* [Link to course](https://academy.arjancodes.com/next-level-python)
* [Source Code](../Projects/NextLevelPython/)

## Static Typing

In static typing, variables are explicitly declared with their data types at compile time, and the type checking is performed at compile time.
Once a variable is declared with a specific data type, it cannot hold values of any other type. This restriction helps catch type-related errors early in the development process.
Examples of statically typed languages include Java, C, C++, and Swift.

## Dynamic Typing

In dynamic typing, variables are not bound to a specific data type at compile time. Instead, the type of a variable is determined at runtime based on the value assigned to it.
Type checking is typically performed at runtime, as opposed to compile time. This means that type errors might only be discovered while the program is running.
Dynamic typing provides more flexibility as variables can hold values of any type and can change their type during runtime.
Examples of dynamically typed languages include Python, JavaScript, and Ruby.

## Duck Typing In Python

In Python, instead of checking if an object belongs to a specific class or type, you check if it supports certain methods or behaviors. If an object implements the necessary methods or attributes, it can be used in a particular context, regardless of its actual type or class.

In `../Projects/NextLevelPython/duck_typing.py` we see the `len()` function expects an Object of type `Sized` which means this Object needs to have a `__len__()` dunder method.

[In other words](https://www.pythonmorsels.com/making-the-len-function-work-on-your-python-objects/):

```text
Python's built-in len function calls the __len__ method (pronounced "dunder len") on the object you give it.

So if that object has a __len__ method, it has a length.
```

## Type Hint/Annotation

It's easy to add type hints in Python, we simply use the `:` and declare what type our variable is/what variables it's made of.

```python
my_str: str = "Hello World"
my_list: list[int] = [34, 54, 65, 78]
my_dict: dict[str, int] = {"one": 123, "two": 456, "three": 789}
```

For instances where we provide the "wrong" type hint, we won't see an error because python does not execute type hints. We must remember that type hints are for the Developer to debug and understand variable requirements.

We can use `strict` type checking mode in VSCode by adding the following setting in our workspace.json file. See [VSCode Docs](https://code.visualstudio.com/docs/python/settings-reference#_python-language-server-settings)

```json
"settings":
    {
        "python.analysis.typeCheckingMode": "strict"
    }
```

We can also leverage the union type syntax which allows us to declare "or" statements when specifying type hints. We can see this in the `protocol_before.py` `EmailClient` class initializer.

```python
class EmailClient:
    def __init__(
        self,
        login: str | None = None,
        password: str | None = None,
        name: str | None = None,
        to_address: str = DEFAULT_EMAIL,
    ):
```

### Protocol Class

"A protocol is a set of methods or attributes that an object must have in order to be considered compatible with that protocol. Protocols enable you to define interfaces without explicitly creating a class or inheriting from a specific base class."

[Reference Link](https://dev.to/shameerchagani/what-is-a-protocol-in-python-3fl1)

To understand this, we will look at `../Projects/NextLevelPython/protocol_before.py`. This file contains an `EmailClient` class which represents the scaffold for a basic email sending system. The breakdown is very simple:

1. Initializer captures user information.
2. Create `SMTP` server and log in using user provided credentials.
3. Build Connect and Quit server connections methods.
4. Build a Send Email method that calls the `SMTP` methods defined previously.

Now, the way we've developed this `EmailClient` functionality has created a dependency between our custom `EmailClient` class and the library which provides the `SMTP`.

To remove this dependency and improve our `EmailClient` implementation we use a `Protocol` class. Here, we will specify the structure of the object we should expect, i.e the structure our `self._server` should have and not worry about specifics.

The file, `../Projects/NextLevelPython/protocol_after.py` contains the `Protocol` implementation.

We first start by defining the "Protocol" an `EmailServer` should follow.

```python
from typing import Protocol

DEFAULT_EMAIL = "support@arjancodes.com"
LOGIN = "admin"
PASSWORD = "admin"


class EmailServer(Protocol):
    @property
    def _host(self) -> str: ...

    def connect(self, host: str, port: int) -> None: ...

    def starttls(self) -> None: ...

    def login(self, login: str, password: str) -> None: ...

    def quit(self) -> None: ...

    def sendmail(self, from_address: str, to_address: str,
                 message: str) -> None: ...

```

And now, we pass this `EmailServer` protocol as the instance type of the `smtp_server` used in our `EmailClient`.

```python
class EmailClient:
    def __init__(
        self,
        smtp_server: EmailServer,
        login: str | None = None,
        password: str | None = None,
        name: str | None = None,
        to_address: str = DEFAULT_EMAIL,
    ):
```

So now, when we initialize our `EmailClient` we pass whatever `SMTP` server instance we want to use - as long as that instance contains the methods in our `EmailServer` protocol. This works because we've provided the Protocol as the type for this `smtp_server` which is provided to our `EmailClient` in the initializer. This is called Dependency Injection; [learn more about this](https://www.youtube.com/watch?v=fhwhQjY2GCY&ab_channel=ArjanCodes)

## DataClasses

To understand dataclasses, we'll first take a look at a simple `Person` class definition.

```python
import random
import string

def generate_id() -> str:
    return "".join(random.choices(string.ascii_uppercase, k=12))


class Person:
    def __init__(self, name: str, address: str):
        self.id = generate_id()
        self.name = name
        self.address = address
        self.email_addresses = []


def main() -> None:
    person = Person(name="John", address="123 Main St")
    print(person)


if __name__ == "__main__":
    main()

```

We can represent this same `Person` object with a dataclass. However, there is some debate about the usage of a dataclass where some argue a dataclass should instead represent, data. That is pointers, arrays, coordinates etc.

So, to convert this `Person` to a dataclass we do the following:

```python
import random
import string
from dataclasses import dataclass, field


def generate_id() -> str:
    return "".join(random.choices(string.ascii_uppercase, k=12))


@dataclass
class Person:
    name: str
    address: str
    active: bool = True
    email_addresses: list[str] = field(default_factory=list)
    id: str = field(init=False, default_factory=generate_id)
    _search_string: str = field(init=False, repr=False)

    def __post_init__(self):
        self._search_string = f"{self.name} {self.address}"


def main() -> None:
    person = Person(name="John", address="123 Main St")
    print(person)


if __name__ == "__main__":
    main()
```

### Understanding our Person Dataclass

If we move this to a file called `person_dataclass.py` and run, we'll see that dataclasses takes care of the `__str__` dunder method and we get a useful print of this person instance we created. More specifically, this is done by automatically implementing the wrapper dunder method.

```terminal
Person(name='John', address='123 Main St', active=True, email_addresses=[], id='AHZCUUETJJRC')
```

Other changes to note here is the use of `field()` to call our `generate_id()` function. The `default_factory` argument is where we specify what method will generate our id. Also, because our `id` now has a "default" value, we have to place it below all fields that do not have a default value defined. Here we've also removed the `id` from the initializer to create a new id by default and not require the user to provide an `id` - we do this by declaring `init=false` in the field definition.

[Learn more about Dataclass fields](https://docs.python.org/3/library/dataclasses.html#dataclasses.field)

```python
id: str = field(init=False, default_factory=generate_id)
```

For `email_addresses` we cannot simply declare `email_addresses: list[str] = []` because this will create an empty list that has the potential to be referenced by other functions - in other words, this list is now "open" for anyone to add elements to it. So instead, we use the `field(default_factory=list)` value. This is how we say "email_addresses is a list of email addresses."

```python
email_addresses: list[str] = field(default_factory=list)
```

For `search_string` we are wanting to create a string we can search a person by. This search string is derived from `name` and `address` but since we don't have these values yet; we are just declaring variables not executing; we have to move this to a `__post__init__()` method. This is essentially saying "capture the name and address values passed to our Person initializer  AND THEN create the search string."


We can remove the `search_string` from the string representation of our Person class by using `repr=False`; this just means we'll no longer see search_string in the terminal. And lastly, to declare that `search_string` is something that's internal to the class, we use the `_search_string` declaration.

```python
_search_string: str = field(init=False, repr=False)

    def __post_init__(self):
        self._search_string = f"{self.name} {self.address}"
```

## Dataclass Parameters

[Learn more about Dataclass Parameters](https://docs.python.org/3/library/dataclasses.html)

We also have the ability to ask the user to use key-word arguments when initializing a new Person by implementing the following:

Note that by default this is `false`

```python
@dataclass(kw_only=True)
class Person:
    name: str
    address: str
    active: bool = True
    email_addresses: list[str] = field(default_factory=list)
    id: str = field(init=False, default_factory=generate_id)
    _search_string: str = field(init=False, repr=False)
```

```python
person = Person(name="John", address="123 Main St")
```

Another thing we can do is not accept Person instanced modifications. We declare this by implementing the following:

Note that this results in a `dataclasses.FrozenInstanceError`. This `frozen` implementation can be very useful when working with data that should not be modified like Coordinates or `Master` data representations.

```python
@dataclass(frozen=True)
class Person:
    name: str
    address: str
    active: bool = True
    email_addresses: list[str] = field(default_factory=list)
    id: str = field(init=False, default_factory=generate_id)
    _search_string: str = field(init=False, repr=False)
```

One thing to note here is that our `_search_string` is no longer allowed since technically we are "modifying" our instance due to the `__post__init__()` call. So how can we implement `_search_string` on a `frozen` Dataclass? We use Properties!

## Class Properties
